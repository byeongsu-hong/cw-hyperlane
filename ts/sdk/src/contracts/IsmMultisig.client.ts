/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.16.5.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { InstantiateMsg, ExecuteMsg, Binary, ValidatorSet, ThresholdSet, QueryMsg, HexBinary, MigrateMsg, ISMType, ModuleTypeResponse, VerifyResponse } from "./IsmMultisig.types";
export interface IsmMultisigReadOnlyInterface {
  contractAddress: string;
  moduleType: () => Promise<ModuleTypeResponse>;
  verify: ({
    message,
    metadata
  }: {
    message: HexBinary;
    metadata: HexBinary;
  }) => Promise<VerifyResponse>;
}
export class IsmMultisigQueryClient implements IsmMultisigReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.moduleType = this.moduleType.bind(this);
    this.verify = this.verify.bind(this);
  }

  moduleType = async (): Promise<ModuleTypeResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      module_type: {}
    });
  };
  verify = async ({
    message,
    metadata
  }: {
    message: HexBinary;
    metadata: HexBinary;
  }): Promise<VerifyResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      verify: {
        message,
        metadata
      }
    });
  };
}
export interface IsmMultisigInterface extends IsmMultisigReadOnlyInterface {
  contractAddress: string;
  sender: string;
  enrollValidator: ({
    set
  }: {
    set: ValidatorSet;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  enrollValidators: ({
    set
  }: {
    set: ValidatorSet[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  unenrollValidator: ({
    domain,
    validator
  }: {
    domain: number;
    validator: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  setThreshold: ({
    set
  }: {
    set: ThresholdSet;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  setThresholds: ({
    set
  }: {
    set: ThresholdSet[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  initTransferOwnership: ({
    owner
  }: {
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  finishTransferOwnership: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  revokeTransferOwnership: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
export class IsmMultisigClient extends IsmMultisigQueryClient implements IsmMultisigInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.enrollValidator = this.enrollValidator.bind(this);
    this.enrollValidators = this.enrollValidators.bind(this);
    this.unenrollValidator = this.unenrollValidator.bind(this);
    this.setThreshold = this.setThreshold.bind(this);
    this.setThresholds = this.setThresholds.bind(this);
    this.initTransferOwnership = this.initTransferOwnership.bind(this);
    this.finishTransferOwnership = this.finishTransferOwnership.bind(this);
    this.revokeTransferOwnership = this.revokeTransferOwnership.bind(this);
  }

  enrollValidator = async ({
    set
  }: {
    set: ValidatorSet;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      enroll_validator: {
        set
      }
    }, fee, memo, funds);
  };
  enrollValidators = async ({
    set
  }: {
    set: ValidatorSet[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      enroll_validators: {
        set
      }
    }, fee, memo, funds);
  };
  unenrollValidator = async ({
    domain,
    validator
  }: {
    domain: number;
    validator: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unenroll_validator: {
        domain,
        validator
      }
    }, fee, memo, funds);
  };
  setThreshold = async ({
    set
  }: {
    set: ThresholdSet;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_threshold: {
        set
      }
    }, fee, memo, funds);
  };
  setThresholds = async ({
    set
  }: {
    set: ThresholdSet[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_thresholds: {
        set
      }
    }, fee, memo, funds);
  };
  initTransferOwnership = async ({
    owner
  }: {
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      init_transfer_ownership: {
        owner
      }
    }, fee, memo, funds);
  };
  finishTransferOwnership = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      finish_transfer_ownership: {}
    }, fee, memo, funds);
  };
  revokeTransferOwnership = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      revoke_transfer_ownership: {}
    }, fee, memo, funds);
  };
}