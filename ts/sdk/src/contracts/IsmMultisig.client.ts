/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { InstantiateMsg, ExecuteMsg, OwnableMsg, HexBinary, ValidatorSet, ThresholdSet, QueryMsg, OwnableQueryMsg, IsmQueryMsg, MultisigIsmQueryMsg, EnrolledValidatorsResponse, Addr, OwnerResponse, PendingOwnerResponse, IsmType, ModuleTypeResponse, VerifyResponse, VerifyInfoResponse } from "./IsmMultisig.types";
export interface IsmMultisigReadOnlyInterface {
  contractAddress: string;
  ownable: (ownableQueryMsg: OwnableQueryMsg) => Promise<OwnableResponse>;
  ism: (ismQueryMsg: IsmQueryMsg) => Promise<IsmResponse>;
  multisigIsm: (multisigIsmQueryMsg: MultisigIsmQueryMsg) => Promise<MultisigIsmResponse>;
}
export class IsmMultisigQueryClient implements IsmMultisigReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.ownable = this.ownable.bind(this);
    this.ism = this.ism.bind(this);
    this.multisigIsm = this.multisigIsm.bind(this);
  }

  ownable = async (ownableQueryMsg: OwnableQueryMsg): Promise<OwnableResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ownable: ownableQueryMsg
    });
  };
  ism = async (ismQueryMsg: IsmQueryMsg): Promise<IsmResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ism: ismQueryMsg
    });
  };
  multisigIsm = async (multisigIsmQueryMsg: MultisigIsmQueryMsg): Promise<MultisigIsmResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      multisig_ism: multisigIsmQueryMsg
    });
  };
}
export interface IsmMultisigInterface extends IsmMultisigReadOnlyInterface {
  contractAddress: string;
  sender: string;
  ownable: (ownableMsg: OwnableMsg, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  enrollValidator: ({
    set
  }: {
    set: ValidatorSet;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  enrollValidators: ({
    set
  }: {
    set: ValidatorSet[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unenrollValidator: ({
    domain,
    validator
  }: {
    domain: number;
    validator: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setThreshold: ({
    set
  }: {
    set: ThresholdSet;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setThresholds: ({
    set
  }: {
    set: ThresholdSet[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class IsmMultisigClient extends IsmMultisigQueryClient implements IsmMultisigInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.ownable = this.ownable.bind(this);
    this.enrollValidator = this.enrollValidator.bind(this);
    this.enrollValidators = this.enrollValidators.bind(this);
    this.unenrollValidator = this.unenrollValidator.bind(this);
    this.setThreshold = this.setThreshold.bind(this);
    this.setThresholds = this.setThresholds.bind(this);
  }

  ownable = async (ownableMsg: OwnableMsg, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      ownable: ownableMsg
    }, fee, memo, _funds);
  };
  enrollValidator = async ({
    set
  }: {
    set: ValidatorSet;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      enroll_validator: {
        set
      }
    }, fee, memo, _funds);
  };
  enrollValidators = async ({
    set
  }: {
    set: ValidatorSet[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      enroll_validators: {
        set
      }
    }, fee, memo, _funds);
  };
  unenrollValidator = async ({
    domain,
    validator
  }: {
    domain: number;
    validator: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unenroll_validator: {
        domain,
        validator
      }
    }, fee, memo, _funds);
  };
  setThreshold = async ({
    set
  }: {
    set: ThresholdSet;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_threshold: {
        set
      }
    }, fee, memo, _funds);
  };
  setThresholds = async ({
    set
  }: {
    set: ThresholdSet[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_thresholds: {
        set
      }
    }, fee, memo, _funds);
  };
}